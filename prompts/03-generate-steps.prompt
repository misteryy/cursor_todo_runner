Decompose this TODO @AgentFirstTODO into ordered execution steps suitable for step-by-step implementation with manual testing between steps.

Output:
- One markdown file per step under docs/TODO/active/steps/
- Filename pattern: P{phase}_{todo}.{step}_{short_slug}.md — do NOT include the word "TODO" in the filename.
  - phase: from the TODO filename (may be versioned, e.g. 1, 2.5)
  - todo: from the TODO filename (may be versioned, e.g. 01, 01.5)
  - step: integer or dotted version (e.g. 01, 02.5, 03.1.2) for sub-steps or insertions
  Derive phase and todo from the Agent-First TODO filename (e.g. P2.5_01.5_Overlay_Styles.md → phase 2.5, todo 01.5).
  Example step filenames: P1_01.01_environment_verification.md, P1_01.02_flutter_create.md, P2.5_01.5.01_overlay_base.md, P2.5_01.5.01.5_overlay_animation.md
- Each step file must contain:
  1. Step number and title
  2. Goal (what this step achieves)
  3. Depends on: (step number or "none")
  4. Concrete tasks (bullet list)
  5. "How to verify" (commands or checks to run; must be runnable; run linter checks only for affected files)
  6. Estimated duration (target ~1 hour or less per step)

---

## GUI vs Backend Step Decomposition

**Backend (atomic):** Data models, services, utilities, pure logic — decompose normally, ~1 hour each.

**Simple GUI (atomic):** Single widgets/components — decompose normally, one step per widget. If the project has a `gui-patterns.json` config, the runner auto-detects GUI steps from path patterns and uses a capable model (via `--GUI_model` if specified, otherwise the `--model` value, or the auto-detected recommendation).

**GUI Integration (compound):** Composing multiple already-built widgets into a container/layout — use `_GUI_` prefix, ~1-2 hours.

### Naming Convention
- Backend: `P{phase}_{todo}.{step}_{description}.md`
- Simple GUI (individual widgets): `P{phase}_{todo}.{step}_{description}.md` (auto-detected from paths when `gui-patterns.json` is configured)
- GUI Integration: `P{phase}_{todo}.{step}_GUI_{description}.md` (explicit, always works)

### When to Use `_GUI_` Prefix (Integration Steps)
Use `_GUI_` prefix ONLY for steps that **integrate/compose** already-built widgets together:
- Combining 2+ existing widgets into a container/screen/layout
- Coordinating shared state between multiple widgets
- Implementing layout constraints that depend on multiple components
- Integration requires visual verification of how components work together

**DO NOT use `_GUI_` for building individual widgets.** Each widget should be its own atomic step.

### Example Decomposition
If a TODO requires: DirectionInput widget, SpeedInput widget, and UncertaintySection container:
- Step 01: Build DirectionInput widget (~1 hour)
- Step 02: Build SpeedInput widget (~1 hour)
- Step 03_GUI: Integrate both widgets into UncertaintySection container (~1-2 hours)

### GUI Integration Step Structure
Include integration tasks as sections, with a focus on layout, state coordination, and visual testing. Add "## Execution Note" stating this is an integration step. Estimated duration: 1-2 hours.

---

## General Rules

- Each step must be independently testable.
- Every step MUST include automated test verification in "How to verify":
  - Logic changes: unit or integration tests.
  - UI changes: component/widget tests (e.g., Testing Library, Flutter widget tests, or equivalent for the stack).
  - API or endpoint changes: integration or e2e tests.
- "How to verify" must specify the exact test command to run.
- Manual or visual-only verification is NOT acceptable when automated testing is possible for the stack.
- Tests must mock or explicitly close any I/O used by the code under test (DB, queues, HTTP servers, timers) so the test runner exits cleanly.
- If the TODO involves database changes, never include a step that requests a full DB reset; use additive migrations only.
- Do NOT write any code yet.
- Do NOT repeat the full design from the TODO; reference it by section (e.g. "per §5 Architectural Approach").
- Do NOT include instructions to move files in any step — the runner handles moving step files and TODOs to completed automatically.
- Do not commit to git.
- Step numbers must reflect intended implementation order (01 before 02, etc.).
- GUI triggers before functionality: when implementing UI features (modals, screens, panels), always implement the button/trigger that opens the feature BEFORE implementing the feature itself. This enables manual testing of the UI flow at each step. Example: a "Select Course" button step should precede the course selector modal step.

Before Creating Step Files:
- Confirm you have no unresolved questions that would affect step scope, order, or verification.
- If the TODO has open questions in §11, resolve them first or surface them now.
- If uncertain about any aspect, surface it now rather than making assumptions.
- Only proceed to create step files when all blocking questions are resolved.

Create only the step files. No summary document unless the TODO explicitly asks for one.
